name: Redeploy Keepalived, Pihole and Nginx via Portainer GitOps

on:
  push:
    branches:
      - main
      - '**'
    paths:
      - '.github/workflows/keepalived-deploy.yml'
      - 'keepalived/**'
  workflow_dispatch:
    inputs:
      host_machine:
        required: true
        type: string 
      domain:
        required: true
        type: string  
  workflow_call:
    inputs:
      domain:
        required: true
        type: string
jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        host_machine: [rpi4-server, e7270-server]
    env:
      domain: ${{ inputs.domain || '14monarch.local' }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set node config
        id: node_config
        run: |
          if [ "${{ matrix.host_machine }}" = "rpi4-server" ]; then
            echo "ssh_host=192.168.0.2" >> $GITHUB_OUTPUT
            echo "ssh_user=liam" >> $GITHUB_OUTPUT
            echo "ssh_key<<EOF" >> $GITHUB_OUTPUT
            echo "${{ secrets.RPI4_SSH_KEY }}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "keepalived_priority=110" >> $GITHUB_OUTPUT
            echo "keepalived_state=MASTER" >> $GITHUB_OUTPUT
            echo "rsync_target_host=192.168.0.4" >> $GITHUB_OUTPUT
            echo "rsync_target_user=liam" >> $GITHUB_OUTPUT
            echo "rsync_target_key<<EOF" >> $GITHUB_OUTPUT
            echo "${{ secrets.E7270_SSH_KEY }}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.host_machine }}" = "e7270-server" ]; then
            echo "ssh_host=192.168.0.4" >> $GITHUB_OUTPUT
            echo "ssh_user=liam" >> $GITHUB_OUTPUT
            echo "ssh_key<<EOF" >> $GITHUB_OUTPUT
            echo "${{ secrets.E7270_SSH_KEY }}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "keepalived_priority=100" >> $GITHUB_OUTPUT
            echo "keepalived_state=BACKUP" >> $GITHUB_OUTPUT
            echo "rsync_target_host=192.168.0.2" >> $GITHUB_OUTPUT
            echo "rsync_target_user=liam" >> $GITHUB_OUTPUT
            echo "rsync_target_key<<EOF" >> $GITHUB_OUTPUT
            echo "${{ secrets.RPI4_SSH_KEY }}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Render keepalived config
        run: |
          export KEEPALIVED_VIRTUAL_IP="${{ vars.KEEPALIVED_IP }}"
          export KEEPALIVED_AUTH_PASS="${{ secrets.MYSQL_ROOT_PASSWORD }}"
          export KEEPALIVED_PRIORITY="${{ steps.node_config.outputs.keepalived_priority }}"
          export MASTER_OR_BACKUP_STATE="${{ steps.node_config.outputs.keepalived_state }}"
          envsubst < keepalived/keepalived.conf.template > keepalived/keepalived.conf

      - name: Install WireGuard
        run: |
          sudo apt-get install -y wireguard || (sudo apt-get update && sudo apt-get install -y wireguard)  

      - name: Write WireGuard config
        run: |
          echo "${{ secrets.WG_CONFIG }}" > wg0.conf

      - name: Bring up VPN
        run: |
          sudo wg-quick up ./wg0.conf
          sudo wg show
          
      - name: Override system DNS resolver
        run: |
          sudo rm /etc/resolv.conf
          echo "nameserver 1.1.1.1" | sudo tee /etc/resolv.conf

      - name: Copy configs to host
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ steps.node_config.outputs.ssh_host }}
          username: ${{ steps.node_config.outputs.ssh_user }}
          key: ${{ steps.node_config.outputs.ssh_key }}
          source: "keepalived/keepalived.conf,keepalived/notify.sh"
          target: /opt/stacks/keepalived/
          strip_components: 1
            
      - name: Make state script executable and set permissions
        uses: appleboy/ssh-action@master
        with:
            host: ${{ steps.node_config.outputs.ssh_host }}
            username: ${{ steps.node_config.outputs.ssh_user }}
            key: ${{ steps.node_config.outputs.ssh_key }}
            script: chmod +x /opt/stacks/keepalived/notify.sh          

      - name: Authenticate to Portainer
        id: auth
        run: |
          RESPONSE=$(curl -X POST "${{ vars.RPI4_IP }}:83/api/auth" \
            -H "Content-Type: application/json" \
            -d '{
                 "Username":"${{ vars.APP_USER }}", 
                 "Password":"${{ secrets.APP_PASSWORD }}"
                }')
          TOKEN=$(echo "$RESPONSE" | jq -r '.jwt')
          echo "token=$TOKEN" >> $GITHUB_OUTPUT

      - name: Get Portainer EndpointId
        id: endpoint
        env:
          HOST_MACHINE: ${{ inputs.host_machine || 'rpi4-server' }}
        run: |
          echo "Looking for endpoint with name: $HOST_MACHINE"
          RESPONSE=$(curl -s -X GET "http://${{ vars.RPI4_IP }}:83/api/endpoints" \
            -H "Authorization: Bearer ${{ steps.auth.outputs.token }}")
          ENDPOINT_ID=$(echo "$RESPONSE" | jq -r --arg host_machine "$host_machine" '.[] | select(.Name==$host_machine) | .Id')
          echo "endpoint_id=$ENDPOINT_ID" >> $GITHUB_OUTPUT

      - name: Get Stack ID (if exists)
        id: get_stack_id
        run: |
          STACKS=$(curl --fail -s -X GET "http://${{ vars.RPI4_IP }}:83/api/stacks" \
          -H "Authorization: Bearer ${{ steps.auth.outputs.token }}" || echo "[]")

          # Filter by both Name AND EndpointId
          STACK_ID=$(echo "$STACKS" | jq -r '.[] | select(.Name=="keepalived" and .EndpointId==${{ steps.endpoint.outputs.endpoint_id }}) | .Id')
          
          if [ -z "$STACK_ID" ] || [ "$STACK_ID" = "null" ]; then
            echo "Stack not found for this endpoint."
            echo "stack_id=0" >> $GITHUB_OUTPUT
          else
            echo "Stack found with ID: $STACK_ID" 
            echo "stack_id=$STACK_ID" >> $GITHUB_OUTPUT
          fi
          
      - name: Generate UUID
        if: ${{ steps.get_stack_id.outputs.stack_id == '0' }}
        id: uuid
        run: |
          echo "uuid=$(uuidgen)" >> $GITHUB_OUTPUT

      - name: Create Stack from GitHub
        if: ${{ steps.get_stack_id.outputs.stack_id == '0' }}
        run: |
          echo "Creating stack from GitHub..."
          RESPONSE=$(curl -v -s -S -X POST "http://${{ vars.RPI4_IP }}:83/api/stacks/create/standalone/repository?endpointId=${{ steps.endpoint.outputs.endpoint_id }}" \
          -H "Authorization: Bearer ${{ steps.auth.outputs.token }}" \
          -H "Content-Type: application/json" \
          -d '{
               "Name": "keepalived",
               "RepositoryURL": "https://github.com/liamj-f/homelab-setup",
               "RepositoryReferenceName": "${{ github.ref }}",
               "ComposeFile": "keepalived/keepalived-compose.yml",
               "RepositoryAuthentication": false,
               "AutoUpdate": {
                              "forcePullImage": true,
                              "forceUpdate": true,
                              "Webhook": "${{ steps.uuid.outputs.uuid }}"
                             },
               "Env": [
                       {
                        "name":"SSH_USER",
                        "value":"${{ steps.node_config.outputs.ssh_user }}"
                        },
                       {
                        "name":"PIHOLE_WEBPASSWORD",
                        "value":"${{ secrets.APP_PASSWORD }}"
                        },
                       {
                        "name":"Primary_IP",
                        "value":"${{ steps.node_config.outputs.ssh_host }}"
                        },
                       {
                        "name":"SECONDARY_IP",
                        "value":"${{ steps.node_config.outputs.tartget_host }}"
                        },
                       {
                        "name":"INITIAL_ADMIN_EMAIL",
                        "value":"${{ vars.NGINX_EMAIL }}"
                        }
                       ],
               "Prune": true,
               "StackFileVersion": "3"
              }')

            echo "API Response: $RESPONSE"
            echo "stack_response=$RESPONSE" >> $GITHUB_OUTPUT

      - name: Update Stack
        if: ${{ steps.get_stack_id.outputs.stack_id != '0' }}
        run: |
          curl -s -X PUT "http://${{ vars.RPI4_IP }}:83/api/stacks/${{ steps.get_stack_id.outputs.stack_id }}/git/redeploy?endpointId=${{ steps.endpoint.outputs.endpoint_id }}" \
          -H "Authorization: Bearer ${{ steps.auth.outputs.token }}" \
          -H "Content-Type: application/json" \
          -d '{
               "PullImage": true,
               "RepositoryReferenceName": "${{ github.ref }}",
               "repositoryAuthentication": false,
               "Env": [
                        {
                        "name":"SSH_USER",
                        "value":"${{ steps.node_config.outputs.ssh_user }}"
                        },
                       {
                        "name":"PIHOLE_WEBPASSWORD",
                        "value":"${{ secrets.APP_PASSWORD }}"
                        },
                       {
                        "name":"Primary_IP",
                        "value":"${{ steps.node_config.outputs.ssh_host }}"
                        },
                       {
                        "name":"SECONDARY_IP",
                        "value":"${{ steps.node_config.outputs.target_host }}"
                        },
                       {
                        "name":"INITIAL_ADMIN_EMAIL",
                        "value":"${{ vars.NGINX_EMAIL }}"
                        }
                       ],
               "Prune": true
              }'          

      - name: Pihole Api Auth
        id: pihole_auth
        run: |
          sleep 20
          RESPONSE=$(curl -s -X POST "http://${{ steps.node_config.outputs.ssh_host }}:82/api/auth" \
              -H "Content-Type: application/json" \
              -d '{
                  "password": "${{ secrets.APP_PASSWORD }}"
                  }' )

          CSRF=$(echo "$RESPONSE" | jq -r '.session.csrf')
          SID=$(echo "$RESPONSE" | jq -r '.session.sid')
          echo "sid=$SID" >> $GITHUB_OUTPUT
          echo "csrf=$CSRF" >> $GITHUB_OUTPUT         
          
      - name: Add DNS records to Pihole via API
        # should add wg0 back in as interface here "eth0,wg0
        run: |
          cat <<EOF > pihole_config.json
          {
              "config":{
                  "dns":{
                      "piholePTR":"Hostname",
                      "domain": {
                                  "name": "$domain",
                                  "local": true
                                },
                      "upstreams": [
                                    "1.1.1.1",
                                    "8.8.8.8"
                                    ],
                      "interface": "eth0", 
                      "listeningMode": "single",
                      "revServers":["true,192.168.0.0/24,192.168.0.1,local"],
                      "hosts":[
                              "192.168.0.1 tplink.$domain",
                              "${{ vars.RPI4_IP }} pihole1.$domain",
                              "${{ vars.E7270_IP }} pihole2.$domain",
                              "${{ vars.KEEPALIVED_IP }} nginx.$domain",
                              "${{ vars.RPI4_IP }} portainer.$domain",
                              "${{ vars.E7270_IP }} nextcloud.$domain",
                              "${{ vars.RPI4_IP }} adminer.$domain",
                              "${{ vars.RPI4_IP }} pihole1.$subdomain.duckdns.org",
                              "${{ vars.E7270_IP }} pihole2.$subdomain.duckdns.org",
                              "${{ vars.KEEPALIVED_IP }} nginx.$subdomain.duckdns.org",
                              "${{ vars.RPI4_IP }} portainer.$subdomain.duckdns.org",
                              "${{ vars.E7270_IP }} nextcloud.$subdomain.duckdns.org",
                              "${{ vars.RPI4_IP }} adminer.$subdomain.duckdns.org",
                              ]
                           },                          
                  "dhcp": {
                        "active": true,
                        "start": "192.168.0.10",
                        "end": "192.168.0.254",
                        "router": "192.168.0.1",
                        "netmask": "",
                        "leaseTime": "2h",
                        "ipv6": false,
                        "rapidCommit": false,
                        "multiDNS": false,
                        "logging": false,
                        "ignoreUnknownClients": false,
                        "hosts": [
                                "dc:a6:32:c8:bb:41,${{ vars.RPI4_IP }},,infinite",
                                "b8:27:eb:3a:5d:2a,${{ vars.RPI0_IP }},,infinite",
                                "3c:6a:a7:87:f4:0b,${{ vars.E7270_IP }},,infinite"
                                 ]
                          },
                  "misc": {
                          "dnsmasq_lines": ["dhcp-option=6,${{ vars.KEEPALIVED_IP }}"]
                          }  
                    }
                }
          EOF
                                    
          curl -X PATCH "http://${{ steps.node_config.outputs.ssh_host }}:82/api/config" \
          -H "X-FTL-SID: ${{ steps.pihole_auth.outputs.sid }}" \
          -H "X-FTL-CSRF: ${{ steps.pihole_auth.outputs.csrf }}" \
          -H 'accept: application/json' \
          -H 'content-type: application/json' \
          -d "@pihole_config.json"


      - name: Add Blocklists to Pihole via API
        run: |
          curl -X POST "http://${{ steps.node_config.outputs.ssh_host }}:82/api/lists?type=block" \
          -H "X-FTL-SID: ${{ steps.pihole_auth.outputs.sid }}" \
          -H "X-FTL-CSRF: ${{ steps.pihole_auth.outputs.csrf }}" \
          -H 'accept: application/json' \
          -H 'content-type: application/json' \
          -d '{
              "address": [
                          "https://v.firebog.net/hosts/Easylist.txt",
                          "https://media.githubusercontent.com/media/zachlagden/Pi-hole-Optimized-Blocklists/refs/heads/main/lists/advertising.txt",
                          "https://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts"
                          ],
              "comment": "Added via API",
              "groups": [0],
              "enabled": true
              }'

      - name: Update Gravity via API
        run: |
          curl -X POST "http://${{ steps.node_config.outputs.ssh_host }}:82/api/action/gravity" \
          -H "X-FTL-SID: ${{ steps.pihole_auth.outputs.sid }}" \
          -H "X-FTL-CSRF: ${{ steps.pihole_auth.outputs.csrf }}" \
          -H 'accept: text/plain' \
          -H 'content-type: application/json' \
          
      - name: End Pihole API Session
        run: |
          curl -X DELETE "http://${{ steps.node_config.outputs.ssh_host }}:82/api/auth" \
          -H "X-FTL-SID: ${{ steps.pihole_auth.outputs.sid }}" \
          -H "X-FTL-CSRF: ${{ steps.pihole_auth.outputs.csrf }}" \

      - name: Authenticate as nginx user
        id: token
        run: |
          sleep 20
          RESPONSE=$(curl -s -X POST "http://${{ steps.node_config.outputs.ssh_host }}:81/api/tokens" \
            -H "Content-Type: application/json" \
            -d '{
                 "identity":"${{ vars.NGINX_EMAIL }}",
                 "secret":"${{ secrets.APP_PASSWORD }}"
                 }')
        
          TOKEN=$(echo "$RESPONSE" | jq -r '.token // empty')
          echo "token=$TOKEN" >> $GITHUB_OUTPUT

      - name: Check for Existing DuckDNS Certificate
        id: check_cert
        run: |
          cert_id=$(curl -s -X GET "http://${{ steps.node_config.outputs.ssh_host }}:81/api/nginx/certificates" \
            -H "Authorization: Bearer ${{ steps.token.outputs.token }}" | \
            jq -r --arg fulldomain "*.$subdomain.duckdns.org" '.[] | select(.domain_names[] == $fulldomain) | .id' | head -n 1)

          if [ -n "$cert_id" ] && [ "$cert_id" != "null" ]; then
            echo "Found existing cert! ID: $cert_id"
            echo "cert_id=$cert_id" >> $GITHUB_ENV
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "No matching certificate found."
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Create Certificate for duckdns domain
        id: certificate
        if: ${{ steps.check_cert.outputs.exists == 'false' }}
        run: |
          PAYLOAD=$(cat <<EOF
          {
            "provider": "letsencrypt",
            "domain_names": ["*.$subdomain.duckdns.org", "$subdomain.duckdns.org"],
            "meta": {
              "dns_challenge": true,
              "dns_provider": "duckdns",
              "dns_provider_credentials": "dns_duckdns_token=${{ secrets.DUCKDNS_TOKEN }}",
              "propagation_seconds": 120
            }
          }
          EOF
          )   
            
          RESPONSE=$(curl -s -X POST "http://${{ steps.node_config.outputs.ssh_host }}:81/api/nginx/certificates" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ steps.token.outputs.token }}" \
            -d "$PAYLOAD")
            
          echo "Certificate API Response: $RESPONSE"
            
          # Check for error before proceeding
          if echo "$RESPONSE" | grep -q "error"; then
            echo "Failed to create certificate"
            exit 1
          fi
            
          cert_id=$(echo "$RESPONSE" | jq -r '.id // empty')
          echo "cert_id=$cert_id" >> $GITHUB_ENV
          
      - name: Create Proxy Hosts
        run: |
          declare -A hosts
          hosts["tplink.$domain"]="192.168.0.1:80"
          hosts["nginx.$domain"]="${{ vars.KEEPALIVED_IP }}:81"
          hosts["pihole1.$domain"]="${{ vars.RPI4_IP }}:82"
          hosts["pihole2.$domain"]="${{ vars.E7270_IP }}:82"

          hosts["portainer.$domain"]="${{ vars.RPI4_IP }}:83"
          hosts["nextcloud.$domain"]="${{ vars.E7270_IP }}:85"
          hosts["adminer.$domain"]="${{ vars.E7270_IP }}:86"
          
          for domain in "${!hosts[@]}"; do
            host="${hosts[$domain]}"
            host_ip="${host%%:*}"
            host_port="${host##*:}"

            curl -s -X POST "http://${{ steps.node_config.outputs.ssh_host }}:81/api/nginx/proxy-hosts" \
              -H "Authorization: Bearer ${{ steps.token.outputs.token }}" \
              -H "Content-Type: application/json" \
              -d '{
                "domain_names": ["'"$domain"'"],
                "forward_host": "'"$host_ip"'",
                "forward_port": '"$host_port"',
                "forward_scheme": "http",
                "ssl_forced": false,
                "enabled": true,
              }' | jq
          done

      - name: Create DuckDNS Proxy Hosts
        run: |
          declare -A hosts
          hosts["tplink.$subdomain.duckdns.org"]="192.168.0.1:80"
          hosts["nginx.$subdomain.duckdns.org"]="${{ vars.KEEPALIVED_IP }}:81"
          hosts["pihole1.$subdomain.duckdns.org"]="${{ vars.RPI4_IP }}:82"
          hosts["pihole2.$subdomain.duckdns.org"]="${{ vars.E7270_IP }}:82"

          hosts["portainer.$subdomain.duckdns.org"]="${{ vars.RPI4_IP }}:83"
          hosts["nextcloud.$subdomain.duckdns.org"]="${{ vars.E7270_IP }}:85"
          hosts["adminer.$subdomain.duckdns.org"]="${{ vars.E7270_IP }}:86"
          
          for domain in "${!hosts[@]}"; do
            host="${hosts[$domain]}"
            host_ip="${host%%:*}"
            host_port="${host##*:}"
            BODY=$(jq -n \
                          --arg domain "$domain" \
                          --arg host_ip "$host_ip" \
                          --argjson host_port "$host_port" \
                          --argjson cert_id "$cert_id" \
                          '{
                            domain_names: [$domain],
                            forward_host: $host_ip,
                            forward_port: $host_port,
                            forward_scheme: "http",
                            ssl_forced: true,
                            enabled: true,
                            certificate_id: $cert_id,
                            block_exploits: true,
                            meta: { letsencrypt_agree: false, dns_challenge: false }
                          }')

            echo "Attempting to create Proxy Host: $domain"
            
            RESPONSE=$(curl -s -X POST "http://${{ steps.node_config.outputs.ssh_host }}:81/api/nginx/proxy-hosts" \
              -H "Authorization: Bearer ${{ steps.token.outputs.token }}" \
              -H "Content-Type: application/json" \
              -d "$BODY")

            # 2. Check if creation failed because the domain exists
            if echo "$RESPONSE" | grep -qE "already in use|400"; then
              echo "Domain $domain already exists. Fetching ID to perform UPDATE (PUT) instead..."
              
              # Find the ID of the existing host by filtering the list
              
              EXISTING_ID=$(curl -s -X GET "http://${{ steps.node_config.outputs.ssh_host }}:81/api/nginx/proxy-hosts" \
                -H "Authorization: Bearer ${{ steps.token.outputs.token }}" | \
                jq -r ".[] | select(.domain_names[] == \"$domain\") | .id")

              if [ "$EXISTING_ID" != "null" ] && [ -n "$EXISTING_ID" ]; then
                echo "Updating existing host ID: $EXISTING_ID"
                curl -s -X PUT "http://${{ steps.node_config.outputs.ssh_host }}:81/api/nginx/proxy-hosts/$EXISTING_ID" \
                  -H "Authorization: Bearer ${{ steps.token.outputs.token }}" \
                  -H "Content-Type: application/json" \
                  -d "$BODY" | jq
              else
                echo "Error: Could not find the ID for $domain even though it's 'in use'."
              fi
            else
              echo "Successfully created $domain"
              echo "$RESPONSE" | jq
            fi
          done


      - name: Bring down VPN
        run: |
          sudo wg-quick down ./wg0.conf
          sudo wg show   

