#!/usr/bin/env python3
"""
Pi-hole hostname scanner using modern /admin/api/config/hosts (v6+).

Features:
- Ping sweep of LAN_SUBNET
- Reverse DNS, mDNS, NetBIOS resolution
- PUT /config/hosts for adding/updating
- DELETE /config/hosts for stale entries
- DRY_RUN support
- Safe loop with exception handling
"""

import os
import time
import socket
import requests
import subprocess
import traceback
from ipaddress import ip_network
from datetime import datetime, timedelta

# ---------------------------
# Configuration
# ---------------------------
PIHOLE_HOST = os.getenv("PIHOLE_HOST", "pihole.local")
PIHOLE_PORT = os.getenv("PIHOLE_PORT", "80")
PI_PASSWORD = os.getenv("PI_PASSWORD")  # session auth
LAN_SUBNET = os.getenv("LAN_SUBNET", "192.168.0.0/24")
PI_HOST_IP = os.getenv("PI_HOST_IP")  # do not delete
SCAN_INTERVAL = int(os.getenv("SCAN_INTERVAL", "300"))
DRY_RUN = os.getenv("DRY_RUN", "0") == "1"
PING_TIMEOUT = float(os.getenv("PING_TIMEOUT", "1.0"))
MDNS_TIMEOUT = int(os.getenv("MDNS_TIMEOUT", "2"))
NBTSCAN_TIMEOUT = int(os.getenv("NBTSCAN_TIMEOUT", "25"))

BASE = f"http://{PIHOLE_HOST}:{PIHOLE_PORT}"
AUTH_URL = f"{BASE}/api/auth"
CONFIG_HOSTS_URL = f"{BASE}/admin/api/config/hosts"

# ---------------------------
# Logging
# ---------------------------
def log(msg):
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{ts}] {msg}", flush=True)

# ---------------------------
# Utilities
# ---------------------------
def run_subprocess(cmd, timeout=None):
    try:
        out = subprocess.check_output(cmd, stderr=subprocess.DEVNULL, timeout=timeout).decode().strip()
        return out
    except subprocess.TimeoutExpired:
        log(f"[!] subprocess timeout: {' '.join(cmd)}")
    except subprocess.CalledProcessError:
        pass
    except FileNotFoundError:
        log(f"[!] command not found: {cmd[0]}")
    return None

def ping_host(ip):
    try:
        res = subprocess.run(
            ["ping", "-c", "1", "-W", str(int(PING_TIMEOUT)), ip],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            timeout=PING_TIMEOUT + 1
        )
        return res.returncode == 0
    except Exception:
        return False

def scan_network(subnet):
    net = ip_network(subnet)
    alive = []
    log(f"[i] Performing ping sweep of {subnet}")
    for ip in net.hosts():
        ipstr = str(ip)
        if ping_host(ipstr):
            alive.append(ipstr)
    log(f"[i] Ping sweep found {len(alive)} alive hosts")
    return alive

def resolve_reverse(ip):
    try:
        return socket.gethostbyaddr(ip)[0]
    except Exception:
        return None

def resolve_mdns(ip):
    out = run_subprocess(["avahi-resolve-address", ip], timeout=MDNS_TIMEOUT)
    if out and " " in out:
        parts = out.split(None, 1)
        if len(parts) == 2:
            return parts[1]
    return None

def resolve_netbios_from_nbtscan_output(nbtscan_out):
    mapping = {}
    if not nbtscan_out:
        return mapping
    for line in nbtscan_out.splitlines():
        line = line.strip()
        if not line or ":" not in line or "Sendto failed" in line:
            continue
        parts = line.split(":")
        if len(parts) >= 2:
            ip = parts[0].strip()
            name = parts[1].strip()
            if ip and name:
                mapping[ip] = name
    return mapping

def run_nbtscan(subnet):
    log(f"[i] Running nbtscan for {subnet} (timeout {NBTSCAN_TIMEOUT}s)")
    out = run_subprocess(["nbtscan", "-s:", subnet], timeout=NBTSCAN_TIMEOUT)
    return resolve_netbios_from_nbtscan_output(out)

# ---------------------------
# Pi-hole API
# ---------------------------
class PiHoleAPI:
    def __init__(self):
        self.session = requests.Session()
        self.csrf = None
        self._auth_session()

    def _auth_session(self):
        if not PI_PASSWORD:
            log("[!] PI_PASSWORD must be set")
            raise SystemExit(1)
        try:
            r = self.session.post(AUTH_URL, json={"password": PI_PASSWORD}, timeout=10)
            r.raise_for_status()
            j = r.json()
            self.csrf = j.get("session", {}).get("csrf")
            log(f"[i] Authenticated to Pi-hole via /api/auth. CSRF present: {bool(self.csrf)}")
        except Exception as e:
            log(f"[!] Failed to authenticate: {e}")
            raise

    def _headers(self):
        h = {}
        if self.csrf:
            h["X-CSRF-Token"] = self.csrf
        return h

def put_host(self, hostname, ip):
    url = f"{CONFIG_HOSTS_URL}/{hostname}"
    data = {"ip": ip}
    log(f"[DEBUG] PUT URL: {url} | Body: {data}")   # <-- log the full request
    if DRY_RUN:
        log(f"[DRY RUN] Would PUT {hostname} -> {ip}")
        return
    try:
        r = self.session.put(url, json=data, headers=self._headers(), timeout=10)
        r.raise_for_status()
        log(f"[+] PUT {hostname} -> {ip}")
    except Exception as e:
        log(f"[!] Failed PUT {hostname}: {e}")
        if hasattr(e, "response") and e.response is not None:
            log(f"[DEBUG] Response: {e.response.status_code} {e.response.text[:300]}")

def delete_host(self, hostname):
    url = f"{CONFIG_HOSTS_URL}/{hostname}"
    log(f"[DEBUG] DELETE URL: {url}")   # <-- log the full request
    if DRY_RUN:
        log(f"[DRY RUN] Would DELETE {hostname}")
        return
    try:
        r = self.session.delete(url, headers=self._headers(), timeout=10)
        r.raise_for_status()
        log(f"[-] DELETE {hostname}")
    except Exception as e:
        log(f"[!] Failed DELETE {hostname}: {e}")
        if hasattr(e, "response") and e.response is not None:
            log(f"[DEBUG] Response: {e.response.status_code} {e.response.text[:300]}")


# ---------------------------
# Main scan logic
# ---------------------------
def run_scan(api):
    alive_ips = set(scan_network(LAN_SUBNET))
    nbtscan_map = run_nbtscan(LAN_SUBNET)
    found = {}
    for ip in alive_ips:
        name = resolve_reverse(ip) or nbtscan_map.get(ip) or resolve_mdns(ip)
        if name:
            found[ip] = name.rstrip(".")

    log(f"[i] Resolved {len(found)} hostnames out of {len(alive_ips)} alive hosts")

    # Add/update hosts
    for ip, hostname in found.items():
        api.put_host(hostname, ip)

    # Optional: prune stale hosts not in active IPs (except PI_HOST_IP)
    # Implement your own stale detection if desired

# ---------------------------
# Main loop
# ---------------------------
if __name__ == "__main__":
    log("[*] Starting Pi-hole hostname scanner (PUT /config/hosts mode)")
    if not PIHOLE_HOST or not PI_HOST_IP:
        log("[!] PIHOLE_HOST and PI_HOST_IP must be set. Exiting.")
        raise SystemExit(1)

    api = PiHoleAPI()

    while True:
        start_time = datetime.now()
        try:
            log(f"[+] Beginning new scan at {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
            run_scan(api)
            log("[âœ“] Scan completed successfully.")
        except Exception as e:
            log(f"[!] Exception during scan: {e}")
            traceback.print_exc()
        finally:
            next_scan = datetime.now() + timedelta(seconds=SCAN_INTERVAL)
            log(f"[~] Sleeping {SCAN_INTERVAL}s... next scan at {next_scan.strftime('%H:%M:%S')}")
            time.sleep(SCAN_INTERVAL)
